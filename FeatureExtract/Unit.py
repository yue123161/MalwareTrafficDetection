import sys

class Unit:
    unitID = ""
    # label 1 malware 0 normal
    label = 0

    # connection parameters
    conn_time = []
    conn_uid = []
    duration = []
    orig_bytes = []
    resp_bytes = []
    orig_pkts = []
    resp_pkts = []
    conn_state = []

    #ssl parameters
    ssl_time = []
    ssl_uid = []
    version = []
    cipher = []
    curve = []
    server_name = []
    resumed = []
    last_alert = []
    next_protocol = []
    established = []
    cert_chain_fuids = []
    client_cert_chain_fuids = []
    subject = []
    issuer = []
    client_subject = []
    client_issuer = []
    validation_status = []
    notary_first_seen = []
    notary_last_seen = []
    notary_times_seen = []
    notary_valid = []



    # connection features
    duration_mean = 0
    duration_standard_deviation = 0
    duration_standard_deviation_range = 0
    orig_bytes_mean = 0
    orig_bytes_standard_deviation = 0
    orig_bytes_standard_deviation_range = 0
    resp_bytes_mean = 0
    resp_bytes_standard_deviation = 0
    resp_bytes_standard_deviation_range = 0
    orig_bytes_ratio = 0
    orig_pkts_mean = 0
    orig_pkts_standard_deviation = 0
    orig_pkts_standard_deviation_range = 0
    resp_pkts_mean = 0
    resp_pkts_standard_deviation = 0
    resp_pkts_standard_deviation_range = 0
    orig_pkts_ratio = 0
    periodicity_mean = 0
    periodicity_standard_deviation = 0
    periodicity_standard_deviation_range = 0
    established_connection_states_ratio = 0

    #ssl features
    ssl_ratio = 0


    def __init__(self, unitID):
        self.unitID = unitID




    def add_conn_label_log(self, conn_label_line):
        '''
        add a data line from conn_label.log
        :param conn_label_line: the data line
        :return:
        '''
        tab = '\t'
        split = conn_label_line.split(tab)
        if not (split[0] == '-' or split[8] == '-' or split[9] == '-' or split[10] == '-' or split[16] == '-' or split[18] == '-'):
            self.conn_time.append(float(split[0]))
            self.conn_uid.append(split[1])
            self.duration.append(float(split[8]))
            self.orig_bytes.append(float(split[9]))
            self.resp_bytes.append(float(split[10]))
            if split[11] in ["SF", "S1", "S2", "S3", "RSTO", "RSTR"]:
                self.conn_state.append(1)
            else:
                self.conn_state.append(0)
            self.orig_pkts.append(float(split[16]))
            self.resp_pkts.append(float(split[18]))
            if split[21] == "botnet":
                self.label = 1
            elif split[21] == "normal":
                self.label = 0
        else:
            print(conn_label_line)

    def add_ssl_log(self, ssl_line):
        """
        add a data line from ssl.log
        :param ssl_line: the data line
        :return:
        """
        tab = '\t'
        split = ssl_line.split(tab)
        self.ssl_time.append(split[0])
        self.ssl_uid.append(split[1])
        self.version.append(split[6])
        self.cipher.append(split[7])
        self.curve.append(split[8])
        self.server_name.append(split[9])
        self.resumed.append(split[10])
        self.last_alert.append(split[11])
        self.next_protocol.append(split[12])
        self.established.append(split[13])
        self.cert_chain_fuids.append(split[14])
        self.client_cert_chain_fuids.append(split[15])
        self.subject.append(split[16])
        self.issuer.append(split[17])
        self.client_subject.append(split[18])
        self.client_issuer.append(split[19])
        self.validation_status.append(split[20])
        self.notary_first_seen.append(split[21])
        self.notary_last_seen.append(split[22])
        self.notary_times_seen.append(split[23])
        self.notary_valid.append(split[24])





    def compute_conn_features(self):
        self.duration_mean = self.mean(self.duration)
        self.duration_standard_deviation = self.standard_deviation(self.duration)
        self.duration_standard_deviation_range = self.standard_deviation_range(self.duration)
        self.orig_bytes_mean = self.mean(self.orig_bytes)
        self.orig_bytes_standard_deviation = self.standard_deviation(self.orig_bytes)
        self.orig_bytes_standard_deviation_range = self.standard_deviation_range(self.orig_bytes)
        self.resp_bytes_mean = self.mean(self.resp_bytes)
        self.resp_bytes_standard_deviation = self.standard_deviation(self.resp_bytes)
        self.resp_bytes_standard_deviation_range = self.standard_deviation_range(self.resp_bytes)
        self.orig_bytes_ratio = self.ratio(self.orig_bytes, self.resp_bytes)
        self.orig_pkts_mean = self.mean(self.orig_pkts)
        self.orig_pkts_standard_deviation = self.standard_deviation(self.orig_pkts)
        self.orig_pkts_standard_deviation_range = self.standard_deviation_range(self.orig_pkts)
        self.resp_pkts_mean = self.mean(self.resp_pkts)
        self.resp_pkts_standard_deviation = self.mean(self.resp_pkts)
        self.resp_pkts_standard_deviation_range = self.standard_deviation_range(self.resp_pkts)
        self.orig_pkts_ratio = self.ratio(self.orig_pkts, self.resp_pkts)
        #compute periodicity
        if len(self.conn_time) == 1:
            self.periodicity_mean = 0
            self.periodicity_standard_deviation = 0
            self.periodicity_standard_deviation_range = 0
        else:
            firstTime = []
            for i in range(1, len(self.conn_time)):
                firstTime.append(self.conn_time[i]-self.conn_time[i-1])
            self.periodicity_mean = self.mean(firstTime)
            self.periodicity_standard_deviation = self.standard_deviation(firstTime)
            self.periodicity_standard_deviation_range = self.standard_deviation_range(firstTime)
        self.established_connection_states_ratio = self.mean(self.conn_state)


    def mean(self, list):
        """
        compute mean
        :param list: number list
        :return: mean
        """
        sum = 0
        for i in list:
            sum += i
        return sum/len(list)

    def standard_deviation(self, list):
        """
        compute standard deviation
        :param list: number list
        :return: standard deviation
        """
        powersum = 0
        for i in list:
            powersum += pow(i, 2)
        return pow(powersum/len(list)-pow(self.mean(list), 2), 0.5)

    def standard_deviation_range(self, list):
        """
        compute standard deviation range
        :param list: number list
        :return: standard deviation range
        """
        up = self.mean(list) + self.standard_deviation(list)
        down = self.mean(list) - self.standard_deviation(list)
        sum = 0
        for i in list:
            if i>up or i<down:
                sum += 1
        return sum/len(list)

    def ratio(self, lista, listb):
        """
        compute the percentage of lista sum
        :param lista: number list
        :param listb: number list
        :return: percentage
        """
        suma = 0
        sumb = 0
        for i in lista:
            suma += i
        for j in listb:
            sumb += j
        return suma/(suma+sumb)


def extract_unitID(line):
    """
    extract unitID from data line in conn_label
    :param line: data line in conn_label
    :return: unit string
    """
    tab = '\t'
    split = line.split(tab)
    return split[2] + tab + split[4] + tab + split[5] + tab + split[6]


if __name__ == '__main__':
    if len(sys.argv) == 3:
        conn_label_log_path = sys.argv[1]
        conn_features_path = sys.argv[2]


        print(">>>start to read conn_label and compute features")
        conn_label_log_path = "D:\\Work\PyCharm-workspace\\MalwareTrafficDetection\\Dataset\\CTU-Malware-Capture-Botnet-42\\bro\\self_create\\conn_label.log"
        # conn_label_log_path = "/home/jiyuan/Work/MalwareTrafficDetection/Dataset/CTU-Malware-Capture-Botnet-42/bro/self_create/conn_label.log"
        unitDict = {}

        with open(conn_label_log_path) as f:
            for line in f:
                if not line[0] == '#':
                    unitID = extract_unitID(line)
                    if "background" not in line:
                        if unitID not in unitDict:
                            unitDict[unitID] = Unit(unitID)
                        #ssl_flag is default normal, revise when reading ssl_log
                        unitDict[unitID].add_conn_label_log(line)
            num = 0
            for unitID in unitDict:
                unitDict[unitID].compute_conn_features()
                num += 1
                if(num%100 == 0):
                    print(num, "/", len(unitDict))
            f.close()
        print(">>>finish reading conn_label and compute features")

        print(">>>start to write into conn_features")
        tab = '\t'
        conn_features_path = "D:\\Work\PyCharm-workspace\\MalwareTrafficDetection\\Dataset\\CTU-Malware-Capture-Botnet-42\\bro\\self_create\\conn_features.log"
        # conn_features_path = "/home/jiyuan/Work/MalwareTrafficDetection/Dataset/CTU-Malware-Capture-Botnet-42/bro/self_create/conn_features.log"
        with open(conn_features_path, 'w') as f:
            for unitID in unitDict.keys():
                unit = unitDict[unitID]
                f.write(str(unit.ssl_ratio ) + tab + str(unit.duration_mean ) + tab + str(unit.duration_standard_deviation ) + tab + str(unit.duration_standard_deviation_range ) + tab + str(unit.orig_bytes_mean ) + tab + str(unit.orig_bytes_standard_deviation ) + tab + str(unit.orig_bytes_standard_deviation_range ) + tab + str(unit.resp_bytes_mean ) + tab + str(unit.resp_bytes_standard_deviation ) + tab + str(unit.resp_bytes_standard_deviation_range ) + tab + str(unit.orig_bytes_ratio ) + tab + str(unit.orig_pkts_mean ) + tab + str(unit.orig_pkts_standard_deviation ) + tab + str(unit.orig_pkts_standard_deviation_range ) + tab + str(unit.resp_pkts_mean ) + tab + str(unit.resp_pkts_standard_deviation ) + tab + str(unit.resp_pkts_standard_deviation_range ) + tab + str(unit.orig_pkts_ratio ) + tab + str(unit.periodicity_mean ) + tab + str(unit.periodicity_standard_deviation ) + tab + str(unit.periodicity_standard_deviation_range ) + tab + str(unit.established_connection_states_ratio ) + '\n')
            f.close()
            print(">>>finish writing into conn_features")
    else:
        print(">>>Error:program is required 2 parameters")
































